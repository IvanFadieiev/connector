exit
login_v2
login_v1
exit
Parser::ProductList.new.array_of_categories_tree(login)
cat_id
exit
a.variants.map{|p| p.update_attributes( 'price': product.special_price.to_i, 'compare_at_price': product.price.to_i )}
a.variants.map{|p| p.update_attributes( 'price': product.price.to_i )}
a.variants.map{|p| p.update_attributes( 'price': 500 )}
a.variants.map{|p| p.update_attributes( 'price': product.price.to_i )}
a.variants.map{|p| p.update_attributes( 'price': "200" )}
a.update_attributes( 'option2': "azaza")
a.id
a.
a.variants.map{|p| p.update_attributes( 'price': product.price.to_f )}
product.price.to_f
product.price
product
a
product
exit
ip
simple
exit
simple[:options][:item]
exit
simple[:options][:item]
simple[:options][:item][:label]
simple[:options][:item][:label] == "Size"
simple[:options][:item]
simple[:options]
!simple[:options]
!simple[:options][:item].include?(:"@xsi:type")
simple[:options][:item].include?(:"@xsi:type")
simple[:options][:item]
simple[:options]
exit
simple[:options][:item]
simple[:options][:item].count
simple[:options][:item]
simple[:options]
simple[:options][:item]
exit
учше
simple[:options][:item].count
simple[:options][:item]юсщгте
simple[:options][:item]
simple[:options][:item].count == 1
simple[:options][:item]
length.blank?
length
exit
учше
exit
length.blank?
s_length = length[0]
c
с
exit
simple[:options][:item].count == 1
continue
s_length    = simple[:options][:item][1][:value]
s_size      = simple[:options][:item][0][:value]
next
туче
simple[:options][:item].count == 1
exit
s
s_length    = s[:value] if s[:label] == "Length"
s_size      = s[:value] if s[:label] == "Size"
step
s_size      = s[:value] if s[:label] == "Size"
next
simple[:options][:item].count
continue
s
next
s_length
 s_size
next
simple[:options][:item][1][:label]
simple[:options][:item][1]
simple[:options][:item][0]
simple[:options][:item].count
simple[:options][:item]
simple[:options][:item][:value]
simple[:options]
exit
simple_products[0]
simple_products.class
simple_products = $client.call(:catalog_product_info, message: {:sessionId => $session, product_id: prod[:product_id] , store_view: login.store_id }).body[:catalog_product_info_response][:info][:associated_products][:item]
simple_products.key
simple_products.class
simple_products[1]
simple_products[0]
simple_products.blank?
simple_products = $client.call(:catalog_product_info, message: {:sessionId => $session, product_id: prod[:product_id] , store_view: login.store_id }).body[:catalog_product_info_response][:info][:associated_products]
prod[:type] == "configurable"
prod[:type]
exit
next
product.qty
exit
Login.last
product.magento_categories.where(login_id: Login.last.id)
product.magento_categories
product.magento_categories.where(login_id: Login.last.id)
product = Product.last
Product.last.magento_categories.last.target_category_import
Product.last.magento_categories.first.target_category_import
Product.last.magento_categories.last.target_category_import
Product.last.magento_categories
JoinTableCategoriesProduct.where(login_id: 90)
Product.last.magento_categories
JoinTableCategoriesProduct.last
oinTableCategoriesProduct.last
products_to_category[0][:item][0][:value]
products_to_category[0[:item][0][:value]
products_to_category[0]
products_to_category.class
next
products_to_category.class == Hash
next
$products_to_category
$products_to_category == nil
products_to_category
exit
next
cat_id
next
ids
next
cat_id
next
cat_id
params
cat_id
next
cat_id
ids
next
 ids.blank? || ids.include?("-2")
next
ids.include?("0")
cat_id
exit
continue
ids
continue
cat_id
exit
params
cat_id = category.category_id
category = array_category.values[0][0]
array_category.values[0][0]
array_category.values[0]
array_category= @all_categories[0]
@all_categories[0]
@all_categories
param_shopify
cat_id
param_shopify = "#{cat_id}_shopify_categories_ids".to_sym
category.category_id
next
ids.include?("-2")
ids.blank?
ids
next
Collection.where(login_id: @login.id).delete_all
 Collection.where(login_id: @login.id)
exit
ids.include?("0")
ids.includes?("0")
ids = params[param_shopify]
param_shopify = "472_shopify_categories_ids".to_sym
params
ids = params[param_shopify]
param_shopify = "10369_shopify_categories_ids".to_sym
"10369_shopify_categories_ids".to_sym
@all_categories[0].values[0].last
@all_categories[0].values[0].count
@all_categories[0].values[0]
@all_categories.values[0]
@all_categories[0]
@all_categories.last
@all_categories.last.count
@all_categories.count
@all_categories.last
@all_categories.count
@all_categories
@all_categories << { 2 => Category.where(level: 2, is_active: 1, login_id: @login.id)}
@all_categories << { a => Category.where(level: 2, is_active: 1, login_id: @login.id)}
 Category.all.map(&:level).uniq.reject{ |a| (a == 0) || (a == 1) }.sort
params
params[param_shopify]
ids
Collection.where(login_id: @login.id)
@login.id
exit
continue
n
cat.description == nil
cat.description
cat
continue
exit
continue
items[:description]
items.keys
items[:description]
items
exit
continue
category
exit
items
exit
Category.delete_all
Category.last
items
exit
c
category
c
category
c
category
c
n
category
exit
items
exit
items[:children][:item].count
items[:children][:item].class
items[:children][:item]
items[:children].keys
items[:children].class
items[:children].class == Hash
items[:children].blank?
items[:children].blank? && items[:children].class == Hash
items[:children].keys
items[:children].class == Hash
items[:children].blank?
next
items
next
items[:name]
items[:amae]
items[:nmae]
items.keys
items
items.keys
items.keys.include?(:category_id)
items.class == Hash
